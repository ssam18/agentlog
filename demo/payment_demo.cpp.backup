/**
 * Payment Service Demo - Full AgentLog Integration
 * Demonstrates AI-powered logging with anomaly detection, pattern recognition,
 * and automatic incident creation to Jira/PagerDuty/Slack simulators
 */

#include <agentlog/agentlog.h>
#include <iostream>
#include <thread>
#include <chrono>
#include <random>
#include <iomanip>

// ANSI color codes for terminal output
#define COLOR_RESET   "\033[0m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_RED     "\033[31m"
#define COLOR_CYAN    "\033[36m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_BOLD    "\033[1m"

// Generate random transaction ID
std::string generate_txn_id() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(100000, 999999);
    return "TXN-" + std::to_string(dis(gen));
}

// Generate random customer ID
std::string generate_customer_id() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(1, 5);
    return "CUST-" + std::to_string(dis(gen));
}

// Simulate payment processing with various scenarios
void process_payment(int iteration) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> outcome_dis(1, 100);
    static std::uniform_int_distribution<> latency_dis(50, 500);
    static std::uniform_real_distribution<> amount_dis(10.0, 500.0);
    
    std::string txn_id = generate_txn_id();
    std::string customer_id = generate_customer_id();
    double amount = std::round(amount_dis(gen) * 100) / 100;
    int outcome = outcome_dis(gen);
    
    // Simulate different outcomes with probabilities
    if (outcome <= 5) {  // 5% - Fraud detection (HIGH anomaly)
        std::cout << COLOR_RED << "[" << iteration << "] " << txn_id 
                  << " - $" << amount << " - ðŸš« FRAUD DETECTED" << COLOR_RESET << "\n";
        
        // This will trigger: Anomaly Detection + Pattern Recognition + Jira Ticket
        AGENTLOG_EVENT("payment.fraud_detected")
            .entity("transaction_id", txn_id)
            .entity("customer_id", customer_id)
            .metric("amount", amount)
            .metric("fraud_score", 0.95)
            .severity(agentlog::Severity::CRITICAL)
            .emit();
        
        std::cout << "  " << COLOR_MAGENTA << "ðŸŽ« AgentLog will create Jira ticket for fraud" << COLOR_RESET << "\n";
        
    } else if (outcome <= 15) {  // 10% - Timeout (triggers PagerDuty)
        int latency = 2000 + (outcome * 100);  // 2000-2500ms
        std::this_thread::sleep_for(std::chrono::milliseconds(latency));
        
        std::cout << COLOR_RED << "[" << iteration << "] " << txn_id 
                  << " - $" << amount << " - ðŸ”´ TIMEOUT (" << latency << "ms)" << COLOR_RESET << "\n";
        
        // High latency will trigger anomaly detection + PagerDuty alert
        AGENTLOG_OBSERVE("payment.latency")
            .metric("latency_ms", static_cast<double>(latency))
            .entity("transaction_id", txn_id)
            .context("endpoint", "/api/payment/process")
            .severity(agentlog::Severity::ERROR)
            .emit();
        
        std::cout << "  " << COLOR_MAGENTA << "ðŸš¨ AgentLog will trigger PagerDuty incident" << COLOR_RESET << "\n";
        
    } else if (outcome <= 25) {  // 10% - Insufficient funds (Slack notification)
        std::cout << COLOR_YELLOW << "[" << iteration << "] " << txn_id 
                  << " - $" << amount << " - âš ï¸  INSUFFICIENT FUNDS" << COLOR_RESET << "\n";
        
        AGENTLOG_EVENT("payment.declined")
            .entity("transaction_id", txn_id)
            .entity("customer_id", customer_id)
            .entity("reason", "insufficient_funds")
            .metric("amount", amount)
            .severity(agentlog::Severity::WARN)
            .emit();
        
        std::cout << "  " << COLOR_MAGENTA << "ðŸ’¬ AgentLog will send Slack notification" << COLOR_RESET << "\n";
        
    } else {  // 75% - Success
        int latency = latency_dis(gen);
        std::this_thread::sleep_for(std::chrono::milliseconds(latency));
        
        std::cout << COLOR_GREEN << "[" << iteration << "] " << txn_id 
                  << " - $" << amount << " - âœ“ SUCCESS (latency: " << latency << "ms)" << COLOR_RESET << "\n";
        
        // Normal metrics - AgentLog learns this as baseline behavior
        AGENTLOG_OBSERVE("payment.latency")
            .metric("latency_ms", static_cast<double>(latency))
            .entity("transaction_id", txn_id)
            .context("endpoint", "/api/payment/process")
            .severity(agentlog::Severity::INFO)
            .emit();
        
        AGENTLOG_EVENT("payment.success")
            .entity("transaction_id", txn_id)
            .entity("customer_id", customer_id)
            .metric("amount", amount)
            .severity(agentlog::Severity::INFO)
            .emit();
    }
}

int main() {
    std::cout << COLOR_BOLD << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘  Payment Service Demo - AgentLog AI-Powered Logging     â•‘\n";
    std::cout << "â•‘  Features: Anomaly Detection, Pattern Recognition       â•‘\n";
    std::cout << "â•‘  Integrations: Jira, PagerDuty, Slack Simulators        â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << COLOR_RESET << "\n\n";
    
    // Initialize AgentLog with AI features enabled
    agentlog::Config config;
    config.service_name = "payment-service";
    config.environment = "demo";
    config.enable_anomaly_detection = true;
    config.enable_pattern_matching = true;
    config.enable_correlation = true;
    config.enable_auto_incidents = true;
    config.incident_threshold = 0.75;  // Create incidents for anomalies > 0.75
    
    // Enable external integrations (simulators)
    config.enable_jira_integration = true;
    config.enable_pagerduty_integration = true;
    config.enable_slack_integration = true;
    
    std::cout << COLOR_CYAN << "âœ“ AgentLog initialized with AI features:" << COLOR_RESET << "\n";
    std::cout << "  â€¢ Anomaly Detection: " << COLOR_GREEN << "ENABLED" << COLOR_RESET << "\n";
    std::cout << "  â€¢ Pattern Recognition: " << COLOR_GREEN << "ENABLED" << COLOR_RESET << "\n";
    std::cout << "  â€¢ Correlation Engine: " << COLOR_GREEN << "ENABLED" << COLOR_RESET << "\n";
    std::cout << "  â€¢ Auto Incidents: " << COLOR_GREEN << "ENABLED" << COLOR_RESET << " (threshold: 0.75)\n\n";
    
    std::cout << COLOR_CYAN << "âœ“ Connected to simulators:" << COLOR_RESET << "\n";
    std::cout << "  - Jira: http://localhost:8080/rest/api/2/issue\n";
    std::cout << "  - PagerDuty: http://localhost:8081/v2/enqueue\n";
    std::cout << "  - Slack: http://localhost:8082\n";
    std::cout << "  - Dashboard: http://localhost:3000\n\n";
    
    try {
        agentlog::global::init(config);
    } catch (const std::exception& e) {
        std::cerr << COLOR_RED << "Failed to initialize AgentLog: " << e.what() << COLOR_RESET << "\n";
        return 1;
    }
    
    std::cout << COLOR_BOLD << "Processing payments (Press Ctrl+C to stop)...\n\n" << COLOR_RESET;
    
    // Process 100 payment transactions
    int success_count = 0;
    int fraud_count = 0;
    int timeout_count = 0;
    int declined_count = 0;
    
    for (int i = 1; i <= 100; ++i) {
        process_payment(i);
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        // Show summary every 20 transactions
        if (i % 20 == 0) {
            std::cout << "\n" << COLOR_BOLD << COLOR_CYAN << "ðŸ“Š SUMMARY (after " << i << " transactions):" << COLOR_RESET << "\n";
            std::cout << "   " << COLOR_GREEN << "âœ… Success: ~" << (i * 75 / 100) << " (75%)" << COLOR_RESET << "\n";
            std::cout << "   " << COLOR_RED << "ðŸš« Fraud: ~" << (i * 5 / 100) << " (5%)" << COLOR_RESET << "\n";
            std::cout << "   " << COLOR_RED << "ðŸ”´ Timeouts: ~" << (i * 10 / 100) << " (10%)" << COLOR_RESET << "\n";
            std::cout << "   " << COLOR_YELLOW << "âš ï¸  Declined: ~" << (i * 10 / 100) << " (10%)" << COLOR_RESET << "\n\n";
        }
    }
    
    std::cout << "\n" << COLOR_BOLD << COLOR_GREEN << "âœ“ Demo completed!" << COLOR_RESET << "\n\n";
    std::cout << COLOR_CYAN << "ðŸ“Š View results in your browser:" << COLOR_RESET << "\n";
    std::cout << "  â€¢ Jira Tickets:        http://localhost:8080\n";
    std::cout << "  â€¢ PagerDuty Incidents: http://localhost:8081\n";
    std::cout << "  â€¢ Slack Messages:      http://localhost:8082\n";
    std::cout << "  â€¢ Dashboard:           http://localhost:3000\n\n";
    
    // Get statistics from AgentLog
    auto stats = agentlog::Logger::instance().get_stats();
    std::cout << COLOR_BOLD << "AgentLog Statistics:" << COLOR_RESET << "\n";
    std::cout << "  Total Events: " << stats.events_total << "\n";
    std::cout << "  Anomalies Detected: " << stats.anomalies_detected << "\n";
    std::cout << "  Incidents Created: " << stats.incidents_created << "\n\n";
    
    agentlog::global::shutdown();
    return 0;
}
        // 70% success
        logger.info("payment.success", "Payment processed successfully", {
            {"transaction_id", req.transaction_id},
            {"customer_id", req.customer_id},
            {"amount", std::to_string(req.amount)},
            {"currency", req.currency},
            {"latency_ms", std::to_string(duration)}
        });
        return true;
        
    } else if (outcome <= 85) {
        // 15% - Insufficient funds
        logger.warn("payment.insufficient_funds", "Payment declined: insufficient funds", {
            {"transaction_id", req.transaction_id},
            {"customer_id", req.customer_id},
            {"amount", std::to_string(req.amount)}
        });
        return false;
        
    } else if (outcome <= 95) {
        // 10% - Gateway timeout (high latency)
        std::this_thread::sleep_for(std::chrono::milliseconds(2000));
        
        logger.error("payment.gateway_timeout", "Payment gateway timeout", {
            {"transaction_id", req.transaction_id},
            {"gateway", "stripe"},
            {"timeout_ms", "5000"},
            {"actual_ms", std::to_string(duration + 2000)}
        });
        
        // This will trigger anomaly detection and PagerDuty alert
        logger.metric("payment.latency", 5000.0, {
            {"transaction_id", req.transaction_id},
            {"status", "timeout"}
        });
        
        return false;
        
    } else {
        // 5% - Critical failure (fraud detection)
        logger.error("payment.fraud_detected", "Suspicious transaction blocked", {
            {"transaction_id", req.transaction_id},
            {"customer_id", req.customer_id},
            {"amount", std::to_string(req.amount)},
            {"fraud_score", "0.95"},
            {"reason", "velocity_check_failed"}
        });
        
        // This should create a Jira ticket
        return false;
    }
}

// Simulate database operations
void simulate_database_queries(AgentLog& logger) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> latency_dis(10, 100);
    static std::uniform_int_distribution<> failure_dis(1, 50);
    
    int latency = latency_dis(gen);
    int failure = failure_dis(gen);
    
    std::this_thread::sleep_for(std::chrono::milliseconds(latency));
    
    if (failure == 1) {
        // 2% database connection failure
        logger.error("database.connection_failed", "Failed to connect to database", {
            {"database", "postgres-primary"},
            {"host", "db.example.com"},
            {"port", "5432"},
            {"error", "connection_timeout"}
        });
    } else {
        logger.metric("database.query_latency", static_cast<double>(latency), {
            {"query_type", "select"},
            {"table", "customers"}
        });
    }
}

// Simulate API calls
void simulate_external_api(AgentLog& logger, const std::string& service) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> latency_dis(100, 800);
    static std::uniform_int_distribution<> failure_dis(1, 20);
    
    int latency = latency_dis(gen);
    int failure = failure_dis(gen);
    
    std::this_thread::sleep_for(std::chrono::milliseconds(latency));
    
    if (failure <= 2) {
        // 10% API failure
        logger.error("api.call_failed", "External API call failed", {
            {"service", service},
            {"endpoint", "/api/v1/validate"},
            {"status_code", "503"},
            {"latency_ms", std::to_string(latency)}
        });
    } else {
        logger.metric("api.latency", static_cast<double>(latency), {
            {"service", service},
            {"status", "success"}
        });
    }
}

int main() {
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘     E-Commerce Payment Service Demo                      â•‘\n";
    std::cout << "â•‘     Demonstrating AgentLog with Jira/PagerDuty/Slack     â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    
    // Initialize AgentLog
    AgentLog logger("payment-service");
    
    std::cout << "âœ“ AgentLog initialized\n";
    std::cout << "âœ“ Connected to simulators:\n";
    std::cout << "  - Jira: http://mock-jira:8080\n";
    std::cout << "  - PagerDuty: http://mock-pagerduty:8081\n";
    std::cout << "  - Slack: http://mock-slack:8082\n";
    std::cout << "  - Dashboard: http://localhost:3000\n\n";
    std::cout << "Processing payments... (Press Ctrl+C to stop)\n\n";
    
    // Customer IDs pool
    std::vector<std::string> customers = {
        "CUST-001", "CUST-002", "CUST-003", "CUST-004", "CUST-005"
    };
    
    // Payment methods
    std::vector<std::string> payment_methods = {
        "credit_card", "debit_card", "paypal", "stripe", "apple_pay"
    };
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> customer_dis(0, customers.size() - 1);
    std::uniform_int_distribution<> method_dis(0, payment_methods.size() - 1);
    std::uniform_real_distribution<> amount_dis(10.0, 500.0);
    
    int transaction_count = 0;
    
    while (true) {
        // Generate random payment request
        PaymentRequest req{
            generate_transaction_id(),
            customers[customer_dis(gen)],
            std::round(amount_dis(gen) * 100.0) / 100.0,
            "USD",
            payment_methods[method_dis(gen)]
        };
        
        transaction_count++;
        
        std::cout << "[" << transaction_count << "] Processing " 
                  << req.transaction_id << " ($" << req.amount << ")\n";
        
        // Simulate payment processing
        bool success = process_payment(logger, req);
        
        // Simulate database queries
        simulate_database_queries(logger);
        
        // Simulate external API calls (randomly)
        if (transaction_count % 5 == 0) {
            simulate_external_api(logger, "fraud-detection");
        }
        
        if (transaction_count % 7 == 0) {
            simulate_external_api(logger, "tax-calculation");
        }
        
        // Periodically send summary to Slack
        if (transaction_count % 20 == 0) {
            logger.info("payment.summary", "Payment processing summary", {
                {"transactions_processed", std::to_string(transaction_count)},
                {"interval", "20 transactions"}
            });
        }
        
        // Wait before next transaction
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }
    
    return 0;
}
